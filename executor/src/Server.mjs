// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Tilia from "tilia/src/Tilia.mjs";
import * as Stdlib_JsError from "@rescript/runtime/lib/es6/Stdlib_JsError.js";
import * as Premise$Executor from "./Database/Premise.mjs";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";
import * as Nodeasync_hooks from "node:async_hooks";
import * as Listener$Executor from "./Database/Listener.mjs";
import * as MockData$Executor from "./MockData/MockData.mjs";
import * as Belt_HashSetString from "@rescript/runtime/lib/es6/Belt_HashSetString.js";
import * as Inventory$Executor from "./Database/Inventory.mjs";
import * as Connection$Executor from "./Database/Connection.mjs";
import * as EntryServer$Executor from "./EntryServer.mjs";

function getPremiseId(req) {
  return req.params["premise_id"];
}

let html_placeholder = `<!--app-html-->`;

let get = async (req, param) => {
  let url = new URL(req.url);
  let headers = {
    "content-type": "text/html"
  };
  let f = Bun.file(process.env.DOC_ROOT + `/index.html`);
  let template = await f.text();
  let match = await EntryServer$Executor.render(url.pathname);
  let stateJson = JSON.stringify(match.executorConfig);
  let html = template.replace(html_placeholder, match.html).replace("</body>", `<script>window.__EXECUTOR_CONFIG__=` + stateJson + `;</script></body>`);
  return new Response(html, {
    status: 200,
    headers: headers
  });
};

let handler_GET = get;

let handler = {
  GET: handler_GET
};

let Frontend = {
  html_placeholder: html_placeholder,
  get: get,
  handler: handler
};

let get$1 = async (req, param) => {
  let headers = new Headers();
  headers.set("content-type", "application/json");
  let response = await Connection$Executor.withClient(async client => {
    let premise_id = req.params["premise_id"];
    let premise = await Premise$Executor.getPremise(client, premise_id);
    let inventory = await Inventory$Executor.getInventoryList(client, premise_id);
    return {
      inventory: inventory,
      premise: premise
    };
  });
  return Response.json(response, {
    status: 200,
    headers: Primitive_option.some(headers)
  });
};

let handler_GET$1 = get$1;

let handler$1 = {
  GET: handler_GET$1
};

let Config = {
  get: get$1,
  handler: handler$1
};

let post = async (req, param) => {
  let premise_id = req.params["premise_id"];
  await Connection$Executor.withClient(async client => await MockData$Executor.createMockData(client, premise_id));
  return new Response("");
};

let handler_POST = post;

let handler$2 = {
  POST: handler_POST
};

let Inventory = {
  post: post,
  handler: handler$2
};

let Route = {
  getPremiseId: getPremiseId,
  Frontend: Frontend,
  Config: Config,
  Inventory: Inventory
};

let storage = new Nodeasync_hooks.AsyncLocalStorage();

if (globalThis.published_signal === undefined) {
  globalThis.published_signal = Tilia.signal(Belt_HashSetString.make(1024));
}

let match = globalThis.published_signal;

let setPublished = match[1];

let published = match[0];

let store = Tilia.tilia({
  published: Tilia.computed(() => Tilia.lift(published))
});

function getStore() {
  return storage.getStore();
}

let SocketState = {
  storage: storage,
  published: published,
  setPublished: setPublished,
  store: store,
  getStore: getStore
};

let server = storage.run(store, param => Bun.serve({
  development: true,
  port: 8899,
  fetch: async (req, server) => {
    let url = new URL(req.url);
    if (url.pathname === "/events") {
      if (server.upgrade(req) === false) {
        Stdlib_JsError.throwWithMessage("Error");
      }
    }
    let filePath = process.env.DOC_ROOT + `/` + url.pathname;
    let file = Bun.file(filePath);
    if (await file.exists()) {
      return new Response(file);
    } else if (typeof get === "object") {
      return new Response("");
    } else if (url.pathname !== "/events") {
      return await get(req, server);
    } else {
      return;
    }
  },
  routes: Object.fromEntries([
    [
      "/",
      handler
    ],
    [
      "/config/:premise_id",
      handler$1
    ],
    [
      "/inventory/:premise_id",
      handler$2
    ]
  ]),
  websocket: {
    message: (ws, message) => {
      console.log("Message received:" + message);
      if (message === "ping") {
        ws.send("pong");
        return;
      }
    },
    open: ws => {
      let websocketUrl = ws["WebSocket.url"];
      let url;
      let exit = 0;
      if (websocketUrl == null) {
        exit = 1;
      } else {
        url = new URL(websocketUrl);
      }
      if (exit === 1) {
        url = new URL(process.env.API_BASE_URL + `/events`);
      }
      let premise_id = url.searchParams.get("premise_id");
      if (premise_id === null) {
        return;
      }
      ws.subscribe(premise_id);
      let store = storage.getStore();
      if (Belt_HashSetString.has(store.published, premise_id) === false) {
        Listener$Executor.withListener(premise_id, message => {
          let premise_id = message.channel;
          Connection$Executor.withClient(client => Promise.resolve(Premise$Executor.getConfig(client, premise_id, url))).then(config => {
            console.log("Got config:");
            console.log(config);
            ws.publish(premise_id, JSON.stringify(config));
            return config;
          });
        });
      }
      Belt_HashSetString.add(store.published, premise_id);
      setPublished(store.published);
    },
    close: (_ws, param, param$1) => {
      console.log("Client disconnected");
    }
  }
}));

let port = server.port.toString();

let hostName = server.hostname;

console.log(`Server listening on http://` + hostName + `:` + port + `!`);

export {
  Route,
  SocketState,
  server,
  port,
  hostName,
}
/* storage Not a pure module */
