// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Tilia from "tilia/src/Tilia.mjs";
import * as Stdlib_List from "@rescript/runtime/lib/es6/Stdlib_List.js";
import * as Stdlib_JsError from "@rescript/runtime/lib/es6/Stdlib_JsError.js";
import * as Constants$Common from "common/./src/Constants.mjs";
import * as Premise$Executor from "./Database/Premise.mjs";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";
import * as Listener$Executor from "./Database/Listener.mjs";
import * as MockData$Executor from "./MockData/MockData.mjs";
import * as Belt_HashSetString from "@rescript/runtime/lib/es6/Belt_HashSetString.js";
import * as Inventory$Executor from "./Database/Inventory.mjs";
import * as Connection$Executor from "./Database/Connection.mjs";
import * as EntryServer$Executor from "./EntryServer.mjs";

function getPremiseId(req) {
  return req.params["premise_id"];
}

let get = async (req, server) => {
  if (server.upgrade(req) === false) {
    Stdlib_JsError.throwWithMessage("Error");
  }
};

let handler_GET = get;

let handler = {
  GET: handler_GET
};

let Events = {
  get: get,
  handler: handler
};

let html_placeholder = `<!--app-html-->`;

let get$1 = async (req, param) => {
  let url = new URL(req.url);
  let headers = {
    "content-type": "text/html"
  };
  let f = Bun.file(process.env.DOC_ROOT + `/index.html`);
  let template = await f.text();
  let match = await EntryServer$Executor.render(url.pathname);
  let stateJson = JSON.stringify(match.executorConfig);
  let html = template.replace(html_placeholder, match.html).replace("</body>", `<script>window.__EXECUTOR_CONFIG__=` + stateJson + `;</script></body>`);
  return new Response(html, {
    status: 200,
    headers: headers
  });
};

let handler_GET$1 = get$1;

let handler$1 = {
  GET: handler_GET$1
};

let Frontend = {
  html_placeholder: html_placeholder,
  get: get$1,
  handler: handler$1
};

let get$2 = async (req, param) => {
  let headers = new Headers();
  headers.set("content-type", "application/json");
  let response = await Connection$Executor.withClient(async client => {
    let premise_id = req.params["premise_id"];
    let premise = await Premise$Executor.getPremise(client, premise_id);
    let inventory = await Inventory$Executor.getInventoryList(client, premise_id);
    return {
      inventory: inventory,
      premise: premise
    };
  });
  return Response.json(response, {
    status: 200,
    headers: Primitive_option.some(headers)
  });
};

let handler_GET$2 = get$2;

let handler$2 = {
  GET: handler_GET$2
};

let Config = {
  get: get$2,
  handler: handler$2
};

let post = async (req, param) => {
  let premise_id = req.params["premise_id"];
  await Connection$Executor.withClient(async client => await MockData$Executor.createMockData(client, premise_id));
  return new Response("");
};

let handler_POST = post;

let handler$3 = {
  POST: handler_POST
};

let Inventory = {
  post: post,
  handler: handler$3
};

let Route = {
  getPremiseId: getPremiseId,
  Events: Events,
  Frontend: Frontend,
  Config: Config,
  Inventory: Inventory
};

if (globalThis.published_signal === undefined) {
  globalThis.published_signal = Tilia.signal(Belt_HashSetString.make(1024));
}

let match = globalThis.published_signal;

let setPublished = match[1];

let published = match[0];

let store = Tilia.tilia({
  published: Tilia.computed(() => Tilia.lift(published))
});

function getStore() {
  return store;
}

let SocketState = {
  published: published,
  setPublished: setPublished,
  store: store,
  getStore: getStore
};

function subscribeTopic(ws, premise_id) {
  console.log("Subscribing to " + premise_id);
  ws.subscribe(premise_id);
  if (Belt_HashSetString.has(store.published, premise_id) === false) {
    Listener$Executor.withListener(premise_id, message => {
      let premise_id = message.channel;
      Connection$Executor.withClient(client => Premise$Executor.getConfig(client, premise_id)).then(config => {
        console.log("Got config:");
        console.log(config);
        ws.publish(premise_id, JSON.stringify(config));
        return Promise.resolve(config);
      });
    });
  }
  Belt_HashSetString.add(store.published, premise_id);
  return setPublished(store.published);
}

let server = Bun.serve({
  development: true,
  port: 8899,
  fetch: async (req, server) => {
    let url = new URL(req.url);
    if (url.pathname === Constants$Common.event_url) {
      if (server.upgrade(req) === false) {
        Stdlib_JsError.throwWithMessage("Error");
      }
    }
    let filePath = process.env.DOC_ROOT + `/` + url.pathname;
    let file = Bun.file(filePath);
    if (await file.exists()) {
      return new Response(file);
    } else if (typeof get$1 === "object") {
      return new Response("");
    } else {
      return await get$1(req, server);
    }
  },
  routes: Object.fromEntries([
    [
      "/",
      handler$1
    ],
    [
      Constants$Common.event_url,
      handler
    ],
    [
      "/config/:premise_id",
      handler$2
    ],
    [
      "/inventory/:premise_id",
      handler$3
    ]
  ]),
  websocket: {
    message: (ws, message) => {
      let match = Stdlib_List.splitAt(Stdlib_List.fromArray(message.split(" ")), 1);
      let match$1 = match[0];
      if (match$1 === 0) {
        return;
      }
      switch (match$1.hd) {
        case "ping" :
          if (match$1.tl !== 0 || match[1] !== 0) {
            return;
          } else {
            ws.send("pong");
            return;
          }
        case "select" :
          if (match$1.tl !== 0) {
            return;
          }
          let match$2 = match[1];
          if (match$2 !== 0 && match$2.tl === 0) {
            return subscribeTopic(ws, match$2.hd);
          } else {
            return;
          }
        default:
          return;
      }
    },
    close: (_ws, param, param$1) => {
      console.log("Client disconnected");
    }
  }
});

let port = server.port.toString();

let hostName = server.hostname;

console.log(`Server listening on http://` + hostName + `:` + port + `!`);

export {
  Route,
  SocketState,
  subscribeTopic,
  server,
  port,
  hostName,
}
/*  Not a pure module */
