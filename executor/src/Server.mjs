// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Tilia from "tilia/src/Tilia.mjs";
import * as Stdlib_JsError from "@rescript/runtime/lib/es6/Stdlib_JsError.js";
import * as Premise$Executor from "./Database/Premise.mjs";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";
import * as Listener$Executor from "./Database/Listener.mjs";
import * as MockData$Executor from "./MockData/MockData.mjs";
import * as Inventory$Executor from "./Database/Inventory.mjs";
import * as Connection$Executor from "./Database/Connection.mjs";
import * as EntryServer$Executor from "./EntryServer.mjs";
import * as PremiseContainer$ExecutorUi from "executor-ui/src/State/PremiseContainer.mjs";

function getPremiseId(req) {
  return req.params["premise_id"];
}

let html_placeholder = `<!--app-html-->`;

let get = async (req, param) => {
  let url = new URL(req.url);
  let headers = {
    "content-type": "text/html"
  };
  let f = Bun.file("../public/index.html");
  let template = await f.text();
  let match = await EntryServer$Executor.render(url.pathname);
  let stateJson = JSON.stringify(match.executorConfig);
  let html = template.replace(html_placeholder, match.html).replace("</body>", `<script>window.__EXECUTOR_CONFIG__=` + stateJson + `;</script></body>`);
  return new Response(html, {
    status: 200,
    headers: headers
  });
};

let handler_GET = get;

let handler = {
  GET: handler_GET
};

let Frontend = {
  html_placeholder: html_placeholder,
  get: get,
  handler: handler
};

let get$1 = async (req, param) => {
  let headers = new Headers();
  headers.set("content-type", "application/json");
  let response = await Connection$Executor.withClient(async client => {
    let premise_id = req.params["premise_id"];
    let premise = await Premise$Executor.getPremise(client, premise_id);
    let inventory = await Inventory$Executor.getInventoryList(client, premise_id);
    return {
      inventory: inventory,
      premise: premise
    };
  });
  return Response.json(response, {
    status: 200,
    headers: Primitive_option.some(headers)
  });
};

let handler_GET$1 = get$1;

let handler$1 = {
  GET: handler_GET$1
};

let Config = {
  get: get$1,
  handler: handler$1
};

let post = async (req, param) => {
  let premise_id = req.params["premise_id"];
  await Connection$Executor.withClient(async client => await MockData$Executor.createMockData(client, premise_id));
  return new Response("");
};

let handler_POST = post;

let handler$2 = {
  POST: handler_POST
};

let Inventory = {
  post: post,
  handler: handler$2
};

let Route = {
  getPremiseId: getPremiseId,
  Frontend: Frontend,
  Config: Config,
  Inventory: Inventory
};

let connections = Tilia.tilia({
  subscriptions: undefined
});

let Clients = {
  subscriptions: undefined,
  connections: connections
};

let server = Bun.serve({
  development: true,
  port: 8899,
  fetch: async (req, server) => {
    let url = new URL(req.url);
    if (url.pathname === "/events") {
      if (server.upgrade(req) === false) {
        Stdlib_JsError.throwWithMessage("Error");
      }
    }
    let filePath = `../public/` + url.pathname;
    let file = Bun.file(filePath);
    if (await file.exists()) {
      return new Response(file);
    } else if (typeof get === "object") {
      return new Response("");
    } else if (url.pathname !== "/events") {
      return await get(req, server);
    } else {
      return;
    }
  },
  routes: Object.fromEntries([
    [
      "/",
      handler
    ],
    [
      "/config/:premise_id",
      handler$1
    ],
    [
      "/inventory/:premise_id",
      handler$2
    ]
  ]),
  websocket: {
    message: (_ws, message) => {
      console.log("Message received:" + message);
    },
    open: ws => {
      let websocketUrl = ws["WebSocket.url"];
      let url;
      let exit = 0;
      if (websocketUrl == null) {
        exit = 1;
      } else {
        url = new URL(websocketUrl);
      }
      if (exit === 1) {
        url = new URL(process.env.API_BASE_URL + `/events?premise_id=` + PremiseContainer$ExecutorUi.premiseId);
      }
      console.log(url);
      let value = url.searchParams.get("premise_id");
      let premise_id;
      premise_id = value === null ? PremiseContainer$ExecutorUi.premiseId : value;
      console.log(premise_id);
      ws.subscribe(premise_id);
      Listener$Executor.withListener(premise_id, message => {
        let premise_id = message.channel;
        Connection$Executor.withClient(client => Promise.resolve(Premise$Executor.getConfig(client, premise_id, url))).then(config => {
          console.log("Got config:");
          console.log(config);
          ws.publish(premise_id, JSON.stringify(config));
          return config;
        });
      });
    },
    close: (_ws, param, param$1) => {
      console.log("Client disconnected");
    }
  }
});

let port = server.port.toString();

let hostName = server.hostname;

console.log(`Server listening on http://` + hostName + `:` + port + `!`);

export {
  Route,
  Clients,
  server,
  port,
  hostName,
}
/* connections Not a pure module */
