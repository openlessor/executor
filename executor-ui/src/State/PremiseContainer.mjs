// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Tilia from "tilia/src/Tilia.mjs";
import * as Stdlib_List from "@rescript/runtime/lib/es6/Stdlib_List.js";

let window = globalThis.window;

let window$1 = (window == null) ? ({
    __EXECUTOR_CONFIG__: null
  }) : window;

let Premise = {};

let base_url = process.env.API_BASE_URL;

async function fetch$1(premiseId) {
  let response = await fetch(base_url + `/config/` + premiseId, {
    method: "get"
  });
  return await response.json();
}

function subscribe(premise_id, updated_at, set) {
  console.log("Premise_id:" + premise_id);
  console.log("updated_at: ");
  console.log(updated_at);
  let url = new URL(process.env.API_BASE_URL + `/events?premise_id=` + premise_id + `&ts=` + updated_at.toString());
  url.protocol = "ws";
  let ws = new WebSocket(url.href);
  let pathname = location.pathname;
  let path = pathname === "/" ? ({
      hd: "/",
      tl: /* [] */0
    }) : Stdlib_List.fromArray(pathname.split("/"));
  console.log(path);
  let match = Tilia.signal(0.0);
  let set_last_pong_ts = match[1];
  let match$1 = Tilia.signal(0.0);
  let set_last_ping_ts = match$1[1];
  let match$2 = Tilia.signal(updated_at);
  let set_updated_ts = match$2[1];
  let state = Tilia.tilia({
    last_ping: Tilia.lift(match$1[0]),
    last_pong: Tilia.lift(match[0]),
    updated_at: Tilia.lift(match$2[0])
  });
  let send_ping = () => {
    if (ws.readyState === 1) {
      ws.send("ping");
      return set_last_ping_ts(new Date("now").getTime());
    }
  };
  Tilia.observe(() => {
    let elapsed = state.last_pong - state.last_ping;
    if (elapsed > 5.0) {
      console.log("No pong received from server, reconnecting...");
      ws.close();
      return subscribe(premise_id, Date.now(), set);
    }
  });
  if (globalThis.interval === undefined) {
    setInterval(() => send_ping(), 5000);
    globalThis.interval = undefined;
  }
  ws.addEventListener("open", _event => {
    ws.send(`select ` + premise_id);
  });
  ws.addEventListener("close", _event => {
    console.log("WebSocket closed, reconnecting");
    subscribe(premise_id, state.updated_at, set);
  });
  ws.addEventListener("message", event => {
    let data = event.data;
    if (data === "pong") {
      return set_last_pong_ts(new Date("now").getTime());
    }
    let input = JSON.parse(data);
    let premise = {
      id: input.premise.id,
      name: input.premise.name,
      description: input.premise.description,
      updated_at: new Date(input.premise.updated_at)
    };
    let config_inventory = input.inventory;
    let config = {
      inventory: config_inventory,
      premise: premise
    };
    set_updated_ts(premise.updated_at.getTime());
    set(config);
  });
}

let empty_inventory = [];

let empty = {
  inventory: empty_inventory,
  premise: undefined
};

let SSR = {
  empty: empty
};

let domExecutorConfig = window$1.__EXECUTOR_CONFIG__;

let initialExecutorConfig;

if (domExecutorConfig == null) {
  initialExecutorConfig = empty;
} else {
  let premise = domExecutorConfig.premise;
  let tmp;
  tmp = (premise == null) ? undefined : ({
      id: premise.id,
      name: premise.name,
      description: premise.description,
      updated_at: new Date(premise.updated_at)
    });
  initialExecutorConfig = {
    inventory: domExecutorConfig.inventory,
    premise: tmp
  };
}

let state = Tilia.source(initialExecutorConfig, async (_prev, set) => {
  let premise = initialExecutorConfig.premise;
  if (premise === undefined) {
    return;
  }
  console.log("PREMISE:");
  console.log(premise);
  let match = globalThis.window;
  if (!(match == null)) {
    return subscribe(premise.id, premise.updated_at.getTime(), set);
  }
});

let Config = {
  fetch: fetch$1
};

export {
  Premise,
  Config,
  SSR,
  state,
}
/* window Not a pure module */
