// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Tilia from "tilia/src/Tilia.mjs";
import * as React from "react";
import * as Stdlib_JSON from "@rescript/runtime/lib/es6/Stdlib_JSON.js";
import * as Stdlib_List from "@rescript/runtime/lib/es6/Stdlib_List.js";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";

let window = globalThis.window;

let window$1 = (window == null) ? ({
    __EXECUTOR_CONFIG__: null
  }) : window;

let base_url = process.env.API_BASE_URL;

async function fetch$1(premiseId) {
  let response = await fetch(base_url + `/config/` + premiseId, {
    method: "get"
  });
  return await response.json();
}

function subscribe(premise_id, set) {
  let url = new URL(process.env.API_BASE_URL + `/events?premise_id=` + premise_id);
  url.protocol = "ws";
  let ws = new WebSocket(url.href);
  let pathname = location.pathname;
  let path = pathname === "/" ? ({
      hd: "/",
      tl: /* [] */0
    }) : Stdlib_List.fromArray(pathname.split("/"));
  console.log(path);
  ws.addEventListener("close", _event => subscribe(premise_id, set));
  ws.addEventListener("message", event => {
    let jsonR = event.data;
    let json = JSON.parse(jsonR);
    set({
      inventory: Stdlib_Option.getOr(Stdlib_Option.flatMap(Stdlib_Option.flatMap(Stdlib_JSON.Decode.object(json), d => d["inventory"]), Stdlib_JSON.Decode.array), []).map(itemJson => itemJson),
      appUrl: path
    });
  });
}

let empty_inventory = [];

let empty = {
  inventory: empty_inventory,
  appUrl: /* [] */0
};

let context = React.createContext(empty);

let provider = context.Provider;

function PremiseContainer$SSR$Provider(props) {
  return React.createElement(provider, {
    value: props.value,
    children: props.children
  });
}

let premiseId = "a55351b1-1b78-4b6c-bd13-6859dc9ad410";

let config = window$1.__EXECUTOR_CONFIG__;

let domExecutorConfig = (config == null) ? null : config;

let initialExecutorConfig = (domExecutorConfig == null) ? empty : domExecutorConfig;

let state = Tilia.source(initialExecutorConfig, async (_prev, set) => {
  let match = globalThis.window;
  if (!(match == null)) {
    return subscribe(premiseId, set);
  }
});

let Config = {
  fetch: fetch$1
};

let SSR_Provider = {
  make: PremiseContainer$SSR$Provider
};

let SSR = {
  empty: empty,
  context: context,
  Provider: SSR_Provider
};

export {
  Config,
  SSR,
  premiseId,
  state,
}
/* window Not a pure module */
