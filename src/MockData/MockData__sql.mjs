// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib from "@rescript/runtime/lib/es6/Stdlib.js";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";
import * as PgtypedRescriptRuntime from "pgtyped-rescript-runtime";

let query1IR = {"usedParamSet":{"premise_id":true,"mock_inventory":true},"params":[{"name":"premise_id","required":true,"transform":{"type":"scalar"},"locs":[{"a":77,"b":88}]},{"name":"mock_inventory","required":true,"transform":{"type":"scalar"},"locs":[{"a":202,"b":217}]}],"statement":"INSERT INTO inventory (premise_id, name, description, quantity)\n  SELECT\n    :premise_id!,\n    mock_inventory.name,\n    mock_inventory.description,\n    0\n  FROM json_populate_recordset(null::inventory, :mock_inventory!) as mock_inventory\n  RETURNING *"};

let query = new PgtypedRescriptRuntime.PreparedQuery(query1IR);

function many(client, params) {
  return query.run(params, client);
}

async function one(client, params) {
  let match = await query.run(params, client);
  if (match.length !== 1) {
    return;
  } else {
    return match[0];
  }
}

async function expectOne(client, params, errorMessage) {
  let match = await query.run(params, client);
  if (match.length !== 1) {
    return Stdlib.panic(Stdlib_Option.getOr(errorMessage, "More or less than one item was returned"));
  } else {
    return match[0];
  }
}

async function execute(client, params) {
  await query.run(params, client);
}

let Query1 = {
  many: many,
  one: one,
  expectOne: expectOne,
  execute: execute
};

function query1(params, client) {
  return query.run(params, client);
}

export {
  Query1,
  query1,
}
/* query Not a pure module */
